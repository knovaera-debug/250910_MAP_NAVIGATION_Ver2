<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>実車評価支援ツール</title>
<link rel="stylesheet" href="leaflet.css" />
<style>
  html,body{height:100%;margin:0}
  #map{position:fixed; inset:0; background:#f2f2f2; transform-origin:center center; z-index:0;}
  #panel{
    position:fixed; left:10px; top:calc(10px + env(safe-area-inset-top));
    z-index:2147483000; background:#fff; padding:10px 12px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.18); font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
    min-width:300px; max-width:min(94vw,560px);
    transition: transform 0.3s ease-in-out;
  }
  .panel-hidden {
    transform: translateX(-110%);
  }
  #panel h1{margin:0 0 8px;font-size:15px;font-weight:700}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:6px 0}
  .row>label{white-space:nowrap}
  .small{font-size:11px;color:#555}
  .grow{flex:1 1 auto;min-width:140px}
  button{padding:10px 14px; min-height:40px; border-radius:12px; cursor:pointer; border:1px solid #ddd; background:#fff;}
  select, input[type=range]{height:40px;border-radius:10px;border:1px solid #ddd;padding:0 8px}
  #start{background:#16a34a;color:#fff;border-color:#16a34a}
  /* #stop{background:#ef4444;color:#fff;border-color:#ef4444} */ /* 削除対象のためコメントアウト */
  #recenter{background:#0ea5e9;color:#fff;border-color:#0ea5e9}
  #cp{background:#f59e0b;color:#fff;border-color:#f59e0b}
  #saveGpx{background:#6366f1;color:#fff;border-color:#6366f1}
  #fabStop{position:fixed; right:calc(12px + env(safe-area-inset-right)); bottom:calc(12px + env(safe-area-inset-bottom));
    z-index:2147483200; display:none; width:84px;height:84px;border-radius:50%; box-shadow:0 12px 36px rgba(0,0,0,.28);
    border:none; background:#ef4444;color:#fff;font-size:16px;font-weight:700;}
  #recBadge{position:fixed; right:12px; top:calc(12px + env(safe-area-inset-top)); z-index:2147483200; display:none; align-items:center; gap:6px;
    background:rgba(239,68,68,.95); color:#fff; padding:6px 10px; border-radius:9999px; box-shadow:0 6px 24px rgba(0,0,0,.18); font-size:12px}
  .dot{width:10px;height:10px;border-radius:50%;background:#fff;animation:blink 1s infinite}
  @keyframes blink{0%,60%{opacity:1}61%,100%{opacity:.25}}
  #toast{position:fixed; left:50%; bottom:calc(78px + env(safe-area-inset-bottom)); transform:translateX(-50%); z-index:2147483100;
    display:none; max-width:min(92vw,560px); background:rgba(0,0,0,.85); color:#fff; padding:10px 14px; border-radius:12px;
    box-shadow:0 6px 24px rgba(0,0,0,.35); font-size:14px}
  #compass{position:fixed; right:calc(14px + env(safe-area-inset-right)); top:calc(74px + env(safe-area-inset-top));
    z-index:2147483001; width:44px;height:44px;border-radius:50%;background:#fff; box-shadow:0 4px 12px rgba(0,0,0,.2);
    display:none; place-items:center; font-size:12px;color:#111;}
  #compassArrow{width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-bottom:14px solid #ef4444;transform-origin:50% 90%}
  #fname{max-width:200px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .counts{font-size:11px;color:#334155;background:#f1f5f9;border-radius:9999px;padding:2px 8px}
  #toggle-panel {
    position: fixed; left: 10px; top: calc(10px + env(safe-area-inset-top));
    z-index: 2147483001; font-size: 24px; cursor: pointer; background: #fff;
    border: none; border-radius: 12px; box-shadow: 0 6px 24px rgba(0,0,0,.18);
    line-height: 1; padding: 10px; display: none;
  }
  #save-modal {
    position: fixed; inset: 0; background: rgba(0, 0, 0, .5); display: none;
    z-index: 2147483002; align-items: center; justify-content: center; padding: 1em;
  }
  #save-modal > div {
    background: #fff; padding: 20px; border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, .2); text-align: center;
  }
  #filename-input {
    width: 100%; max-width: 250px; padding: 8px; margin-bottom: 10px;
    border: 1px solid #ccc; border-radius: 6px;
  }
  #save-modal button {
    padding: 10px 20px; border: none; border-radius: 8px;
    color: #fff; cursor: pointer;
  }
  #save-yes { background-color: #38a169; }
  #save-no { background-color: #e53e3e; }
  #live-info {
    border-top: 1px solid #e2e8f0;
    margin-top: 10px;
    padding-top: 10px;
    font-size: 13px;
  }
  #live-info h2 {
    margin: 0 0 8px;
    font-size: 14px;
    font-weight: 600;
    color: #334155;
  }
  #live-info p {
    margin: 4px 0;
    display: flex;
    justify-content: space-between;
  }
  #live-info p span {
    font-weight: bold;
    color: #1e293b;
    min-width: 80px;
    text-align: right;
  }
</style>
</head>
<body>
<div id="map"></div>

<div id="panel">
  <h1>実車評価支援ツール</h1>

  <div class="row">
    <input type="file" id="file" accept=".kml,.kmz" multiple />
    <select id="datasetSelect" class="grow">
      <option value="" disabled selected>（読み込んだルート／ポイントを選択）</option>
    </select>
    <span id="fname" class="small"></span>
  </div>

  <div class="row">
    <button id="start">追跡開始</button>
    <button id="recenter">現在地へ</button>
    <button id="cp" disabled>チェックポイント</button>
    <span id="counts" class="counts"></span>
  </div>

  <div class="row">
    <label><input type="checkbox" id="keepCentered" checked />自車を常に中心</label>
    <label style="margin-left:10px">向き:</label>
    <label><input type="radio" name="orient" value="north" checked />北を上</label>
    <label><input type="radio" name="orient" value="course" />進行方向を上</label>
  </div>
  
  <div class="row" id="orientation-section">
    <button id="lockPortrait">縦向きに固定</button>
    <button id="lockLandscape">横向きに固定</button>
    <button id="unlockOrientation">固定解除</button>
  </div>

  <div class="row">
    <button id="tts">音声テスト</button>
    <button id="wake">画面オフ防止: OFF</button>
  </div>

  <div class="row">
    <select id="voiceSelect" class="grow"></select>
  </div>

  <div class="row">
    <label class="small" for="ttsRate">話す速度: <span id="ttsRateVal">1.0</span>x</label>
    <input id="ttsRate" type="range" min="0.6" max="1.6" step="0.1" value="1.0" style="width:180px; margin-left:8px;">
  </div>

  <div class="row">
    <label class="small" for="notifyRange">通知半径: <span id="notifyRangeVal">120</span> m</label>
    <input id="notifyRange" type="range" min="20" max="300" step="10" value="120" style="width:180px; margin-left:8px;">
  </div>

  <div class="row">
    <button id="saveGpx" disabled>GPX保存</button>
    <span id="stat" class="small"></span>
  </div>

  <div id="live-info" style="display: none;">
    <h2>ライブ情報</h2>
    <p>速度: <span id="live-speed">-- km/h</span></p>
    <p>高度: <span id="live-altitude">-- m</span></p>
    <p>GPS精度: <span id="live-accuracy">-- m</span></p>
  </div>
</div>

<button id="toggle-panel">☰</button>

<div id="save-modal">
  <div>
    <p>GPXファイルを保存しますか？</p>
    <input type="text" id="filename-input" placeholder="ファイル名を入力" />
    <div>
      <button id="save-yes">保存</button>
      <button id="save-no">キャンセル</button>
    </div>
  </div>
</div>

<button id="fabStop">停止</button>
<div id="recBadge"><div class="dot"></div><div>追跡中</div></div>
<div id="toast"></div>
<div id="compass"><div id="compassArrow"></div></div>

<script src="leaflet.js"></script>
<script src="jszip.min.js"></script>
<script src="togeojson.umd.js"></script>
<script>
(function(){
  /* ==== ユーティリティ ==== */
  function toast(msg, ms=2000){ $toast.textContent=msg; $toast.style.display='block'; setTimeout(()=>{$toast.style.display='none'}, ms); }
  function escapeHTML(s){ return String(s||'').replace(/[&<>\"]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c])); }
  function escapeXML(s){ return escapeHTML(s); }
  function formatTs(){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`; }

  /* ==== ピン定義 ==== */
  function svg(color){return encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="24" height="36" viewBox="0 0 24 36"><path d="M12 36s10-12.2 10-20A10 10 0 1 0 2 16c0 7.8 10 20 10 20z" fill="${color}"/><circle cx="12" cy="12" r="4.5" fill="#fff"/></svg>`)}
  const Blue=L.Icon.extend({options:{iconUrl:`data:image/svg+xml;utf8,${svg('#3b82f6')}`,iconSize:[24,36],iconAnchor:[12,34]}});
  const Gray=L.Icon.extend({options:{iconUrl:`data:image/svg+xml;utf8,${svg('#9ca3af')}`,iconSize:[24,36],iconAnchor:[12,34]}});
  const Orange=L.Icon.extend({options:{iconUrl:`data:image/svg+xml;utf8,${svg('#f59e0b')}`,iconSize:[24,36],iconAnchor:[12,34]}});
  const iconBlue=new Blue(),iconGray=new Gray(),iconOrange=new Orange();

  /* ==== マップ ==== */
  const map=L.map('map',{zoomControl:false});
  // ▼▼▼ 走行軌跡用のpaneとルート用のpaneを追加し、z-indexを設定 ▼▼▼
  map.createPane('routePane');
  map.getPane('routePane').style.zIndex = 300;
  map.createPane('trackPane');
  map.getPane('trackPane').style.zIndex = 450;
  // ▲▲▲ 走行軌跡用のpaneとルート用のpaneを追加し、z-indexを設定 ▲▲▲
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'&copy; OpenStreetMap'}).addTo(map);
  map.setView([35.681,139.767], 16);

  /* ==== UI 要素 ==== */
  const start=document.getElementById('start');
  // const stop=document.getElementById('stop'); // 削除
  const fabStop=document.getElementById('fabStop');
  const recenter=document.getElementById('recenter');
  const keepCentered=document.getElementById('keepCentered');
  const $compass=document.getElementById('compass'),$compassArrow=document.getElementById('compassArrow');
  const $toast=document.getElementById('toast');
  const fileInput=document.getElementById('file');
  const datasetSelect=document.getElementById('datasetSelect');
  const cpBtn=document.getElementById('cp');
  const stat=document.getElementById('stat');
  const counts=document.getElementById('counts');
  const saveGpx=document.getElementById('saveGpx');
  const fname=document.getElementById('fname');
  const panel = document.getElementById('panel');
  const togglePanelBtn = document.getElementById('toggle-panel');
  const saveModal = document.getElementById('save-modal');
  const filenameInput = document.getElementById('filename-input');
  const saveYesBtn = document.getElementById('save-yes');
  const saveNoBtn = document.getElementById('save-no');
  const voiceSelect = document.getElementById('voiceSelect');
  const orientationSection = document.getElementById('orientation-section');
  const lockPortraitBtn = document.getElementById('lockPortrait');
  const lockLandscapeBtn = document.getElementById('lockLandscape');
  const unlockOrientationBtn = document.getElementById('unlockOrientation');
  const liveInfoPanel = document.getElementById('live-info');
  const liveSpeed = document.getElementById('live-speed');
  const liveAltitude = document.getElementById('live-altitude');
  const liveAccuracy = document.getElementById('live-accuracy');

  /* ==== パネル表示/非表示 ==== */
  togglePanelBtn.addEventListener('click', () => {
    panel.classList.toggle('panel-hidden');
    if (panel.classList.contains('panel-hidden')) {
      togglePanelBtn.style.display = 'block';
    } else {
      togglePanelBtn.style.display = 'none';
    }
    updateMapCenter();
  });

  panel.addEventListener('click', (e) => {
    if (e.target.tagName.toLowerCase() === 'button') {
      return;
    }
    panel.classList.add('panel-hidden');
    togglePanelBtn.style.display = 'block';
    updateMapCenter();
  });
  
  window.addEventListener('orientationchange', updateMapCenter);
  window.addEventListener('resize', updateMapCenter);

  /* ==== 画面オフ防止 ==== */
  let wakeLock=null; const wake=document.getElementById('wake');
  async function toggleWake(){
    try{
      if(!wakeLock){ wakeLock=await navigator.wakeLock.request('screen'); wake.textContent='画面オフ防止: ON'; }
      else { await wakeLock.release(); wakeLock=null; wake.textContent='画面オフ防止: OFF'; }
    }catch(e){ toast('画面オフ防止を取得できません'); }
  }
  wake.addEventListener('click',toggleWake);

  /* ==== 画面向きの固定 ==== */
  if (screen.orientation && screen.orientation.lock) {
    lockPortraitBtn.addEventListener('click', async () => {
      try { await screen.orientation.lock('portrait'); toast('画面を縦向きに固定しました'); }
      catch (e) { toast('縦向きに固定できません'); }
    });
    lockLandscapeBtn.addEventListener('click', async () => {
      try { await screen.orientation.lock('landscape'); toast('画面を横向きに固定しました'); }
      catch (e) { toast('横向きに固定できません'); }
    });
    unlockOrientationBtn.addEventListener('click', async () => {
      try { await screen.orientation.unlock(); toast('画面固定を解除しました'); }
      catch (e) { toast('画面固定を解除できません'); }
    });
  } else {
    orientationSection.style.display = 'none';
  }

  /* ==== 方位・回転 ==== */
  let currentBearing=0, orientationMode='north';
  document.querySelectorAll('input[name=orient]').forEach(r=>{
    r.addEventListener('change',()=>{
      orientationMode=r.value;
      if(orientationMode==='north'){ rotateMap(0); $compass.style.display='none'; }
      else { $compass.style.display='grid'; }
    });
  });

  function bearingBetween(a,b){
    const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
    const lat1=toRad(a.lat), lon1=toRad(a.lng), lat2=toRad(b.lat), lon2=toRad(b.lng);
    const y=Math.sin(lon2-lon1)*Math.cos(lat2);
    const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(lon2-lon1);
    return (toDeg(Math.atan2(y,x))+360)%360;
  }

  function rotateMap(bearingDeg){
    const pane = map.getPanes().mapPane;
    currentBearing = bearingDeg || 0;
    pane.style.transform = `rotate(${currentBearing}deg)`;
    updateMapCenter();
  }

  function updateMapCenter() {
    setTimeout(() => {
        if (!lastLatLng || !keepCentered.checked) return;
        map.invalidateSize();
        const mapSize = map.getSize();
        const panelWidth = panel.offsetWidth;
        const panelVisible = !panel.classList.contains('panel-hidden');
        let targetX = mapSize.x / 2;
        let targetY = mapSize.y / 2;
        if (panelVisible) {
            targetX = (mapSize.x / 2) + (panelWidth / 2);
        }
        map.panTo(lastLatLng, { animate: false });
        const mePoint = map.latLngToContainerPoint(lastLatLng);
        const offsetX = targetX - mePoint.x;
        const offsetY = targetY - mePoint.y;
        map.panBy(L.point(offsetX, offsetY), { animate: false });
    }, 100);
  }

  /* ==== TTS ==== */
  let ttsQueue=[],speaking=false,jpVoice=null,ttsUnlocked=false,ttsRate=1.0;
  const $ttsRate=document.getElementById('ttsRate'),$ttsRateVal=document.getElementById('ttsRateVal');
  $ttsRate.addEventListener('input',()=>{ttsRate=+$ttsRate.value; $ttsRateVal.textContent=ttsRate.toFixed(1);});
  function unlockTTS(){
    if(ttsUnlocked)return;
    ttsUnlocked=true;
    speechSynthesis.cancel();
    const voices = speechSynthesis.getVoices();
    voiceSelect.innerHTML = ''; 
    let preferredVoice = null;
    const jaVoices = voices.filter(v => /ja-JP/i.test(v.lang));
    preferredVoice = jaVoices.find(v => /Kyoko|O-ren|Ayumi|Haruka|Female|女性/i.test(v.name));
    if (!preferredVoice && jaVoices.length > 0) {
      preferredVoice = jaVoices[0];
    }
    if (!preferredVoice && voices.length > 0) {
      preferredVoice = voices[0];
    }
    jpVoice = preferredVoice;
    voices.forEach(voice => {
      const option = document.createElement('option');
      option.textContent = `${voice.name} (${voice.lang})`;
      option.value = voice.name;
      if (voice === jpVoice) {
        option.selected = true;
      }
      voiceSelect.appendChild(option);
    });
    voiceSelect.addEventListener('change', () => {
      const selectedVoiceName = voiceSelect.value;
      jpVoice = voices.find(v => v.name === selectedVoiceName);
    });
  }
  speechSynthesis.addEventListener('voiceschanged',unlockTTS);
  function enqueueSpeech(lines){for(const s of lines){const u=new SpeechSynthesisUtterance(String(s)); if(jpVoice)u.voice=jpVoice; u.rate=ttsRate; u.pitch=1.0; ttsQueue.push(u);} if(!speaking)speakNext();}
  function speakNext(){if(!ttsQueue.length){speaking=false;return;}speaking=true;const u=ttsQueue.shift();u.onend=()=>{speaking=false;speakNext();};speechSynthesis.speak(u);}
  document.getElementById('tts').addEventListener('click',()=>{unlockTTS();enqueueSpeech(['音声テストです']);});

  /* ==== 通知半径 ==== */
  let notifyRadius=120;
  const $notifyRange=document.getElementById('notifyRange');
  const $notifyRangeVal=document.getElementById('notifyRangeVal');
  $notifyRange.addEventListener('input',()=>{notifyRadius=+$notifyRange.value; $notifyRangeVal.textContent=notifyRadius;});

  /* ==== レイヤ ==== */
  const pointLayer=L.layerGroup().addTo(map);
  // ▼▼▼ `routePane` を指定 ▼▼▼
  const routeMarkerLayer=L.layerGroup({pane: 'routePane'}).addTo(map);
  const routeLineLayer=L.layerGroup({pane: 'routePane'}).addTo(map);
  // ▲▲▲ `routePane` を指定 ▲▲▲
  const trackLayer=L.layerGroup({pane: 'trackPane'}).addTo(map);
  const checkpointLayer=L.layerGroup().addTo(map);

  function clearDataLayers(){
    pointLayer.clearLayers(); routeMarkerLayer.clearLayers(); routeLineLayer.clearLayers();
  }
  function clearAllLayers(){
    clearDataLayers(); trackLayer.clearLayers(); checkpointLayer.clearLayers();
  }

  /* ==== 自車位置・走行ルート ==== */
  const me = L.circleMarker([35.681,139.767], {
    radius: 7,
    stroke: false,
    fill: true,
    fillColor: '#ef4444',
    fillOpacity: 1
  }).addTo(map);
  
  // ▼▼▼ 走行軌跡の線の太さと色を修正 ▼▼▼
  const trackLineCasing = L.polyline([], {color: '#16a34a', weight: 4, opacity: 0.8, pane: 'trackPane'}).addTo(trackLayer);
  const trackLine = L.polyline([], {color: '#22c55e', weight: 2, opacity: 0.95, pane: 'trackPane'}).addTo(trackLayer);
  // ▲▲▲ 走行軌跡の線の太さと色を修正 ▲▲▲

  /* ==== データセット管理（複数ファイル切替） ==== */
  const datasetMap=new Map();
  let currentKey=null;

  datasetSelect.addEventListener('change',()=>{
    const key=datasetSelect.value;
    if(!key) return;
    activateDataset(key);
  });

  async function parseKmlText(kmlText){
    const xml = new DOMParser().parseFromString(kmlText,'text/xml');
    const fc  = toGeoJSON.kml(xml);
    const out={points:[], routes:[]};
    for(const feat of fc.features){
      const name = feat.properties?.name || '';
      const desc = feat.properties?.description || '';
      if(feat.geometry?.type==='Point'){
        const lower = `${name}\n${desc}`.toLowerCase();
        const looksRoute = /route|ルート|経路|path/.test(lower);
        const latlng=L.latLng(feat.geometry.coordinates[1], feat.geometry.coordinates[0]);
        out.points.push({latlng,name,desc,looksRoute});
      }else if(/LineString|MultiLineString/.test(feat.geometry?.type||'')){
        if(feat.geometry.type==='LineString'){
          out.routes.push(feat.geometry.coordinates.map(c=>L.latLng(c[1],c[0])));
        }else{
          for(const ring of feat.geometry.coordinates){
            out.routes.push(ring.map(c=>L.latLng(c[1],c[0])));
          }
        }
      }
    }
    return out;
  }

  async function loadOneFile(file){
    const arr=await file.arrayBuffer();
    let kmlText='';
    if(/\.kmz$/i.test(file.name)){
      const zip=await JSZip.loadAsync(arr);
      const kmlEntry = Object.values(zip.files).find(z=>/\.kml$/i.test(z.name));
      if(!kmlEntry) throw new Error('KMZ内にKMLが見つかりません');
      kmlText = await kmlEntry.async('text');
    }else{
      kmlText = new TextDecoder().decode(arr);
    }
    const parsed = await parseKmlText(kmlText);
    return {name:file.name, ...parsed};
  }

  function renderDataset(ds){
    clearDataLayers();
    for(const p of ds.points){
      const m=L.marker(p.latlng,{icon: p.looksRoute? iconGray: iconBlue});
      m.bindPopup(`<b>${escapeHTML(p.name||'無題')}</b><div>${escapeHTML(p.desc||'')}</div>`);
      (p.looksRoute? routeMarkerLayer: pointLayer).addLayer(m);
    }
    for(const ring of ds.routes){
      // ▼▼▼ ルートの線の太さと色を修正 ▼▼▼
      const casing = L.polyline(ring, {color: '#854d0e', weight: 8, opacity: 0.85, pane: 'routePane'});
      const poly = L.polyline(ring, {color: '#f59e0b', weight: 5, opacity: 1, pane: 'routePane'});
      // ▲▲▲ ルートの線の太さと色を修正 ▼▼▼
      routeLineLayer.addLayer(casing);
      routeLineLayer.addLayer(poly);
    }
    const bounds = L.latLngBounds([]);
    ds.points.forEach(p=>bounds.extend(p.latlng));
    ds.routes.forEach(r=>r.forEach(ll=>bounds.extend(ll)));
    if(bounds.isValid()) map.fitBounds(bounds.pad(0.1));
    counts.textContent = `ポイント ${ds.points.filter(p=>!p.looksRoute).length} / ルート ${ds.routes.length}`;
  }

  function activateDataset(key){
    const ds = datasetMap.get(key);
    if(!ds) return;
    currentKey=key;
    fname.textContent = ds.name;
    renderDataset(ds);
    notified.clear();
    distanceTravelledSinceSpeak = 0;
  }

  fileInput.addEventListener('change', async (e)=>{
    const files = Array.from(e.target.files||[]);
    if(!files.length) return;
    toast(`読み込み中…(${files.length}件)`, 1800);
    for(const f of files){
      try{
        const ds = await loadOneFile(f);
        const key = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
        datasetMap.set(key, ds);
        const opt=document.createElement('option');
        opt.value=key; opt.textContent=ds.name;
        datasetSelect.appendChild(opt);
        if(!currentKey){ datasetSelect.value=key; activateDataset(key); }
      }catch(err){
        console.error(err);
        toast(`${f.name}: 読み込み失敗（${err.message||err}）`, 3000);
      }
    }
    toast('読み込み完了', 1200);
  });

  /* ==== 近接通知 ==== */
  const RENOTIFY_EVERY_M = 300;
  let notified = new Map();
  function collectNearTexts(here){
    const ds = datasetMap.get(currentKey);
    if(!ds) return [];
    const res=[];
    ds.points.forEach((p, idx)=>{
      if(p.looksRoute) return;
      const d=here.distanceTo(p.latlng);
      if(d <= notifyRadius){
        const n=notified.get(idx) || {lastSpokeAtDist:-Infinity};
        if(!isFinite(n.lastSpokeAtDist) || (distanceTravelled - n.lastSpokeAtDist)>=RENOTIFY_EVERY_M){
          notified.set(idx, {lastSpokeAtDist:distanceTravelled});
          res.push(`${p.name||'ポイント'}。${(p.desc||'').replace(/\s+/g,' ')}`);
        }
      }
    });
    return res;
  }
  function checkNearAndSpeak(here){
    const texts = collectNearTexts(here);
    if(texts.length) { enqueueSpeech(texts); distanceTravelledSinceSpeak = 0; }
  }

  /* ==== 追跡 ==== */
  let tracking=false, watchId=null; let lastLatLng=null, prevLatLng=null; let startupSweepTimer=null;
  let distanceTravelled=0; let distanceTravelledSinceSpeak=0;
  let lastFixTime=0; let weakGpsWarned=false;
  let gpsWeakTimer=null;
  const trackPoints = [];
  const cps=[];

  function onPosition(pos){
    const here = L.latLng(pos.coords.latitude, pos.coords.longitude);
    lastFixTime = Date.now();
    weakGpsWarned=false;
    if(lastLatLng){
      const moved = here.distanceTo(L.latLng(lastLatLng));
      distanceTravelled += moved; distanceTravelledSinceSpeak += moved;
    }
    prevLatLng = lastLatLng? L.latLng(lastLatLng): null;
    lastLatLng = here;
    trackPoints.push(here);
    me.setLatLng(here);
    updateMapCenter();
    const speed = pos.coords.speed;
    const altitude = pos.coords.altitude;
    const accuracy = pos.coords.accuracy;
    liveSpeed.textContent = speed !== null ? `${(speed * 3.6).toFixed(1)} km/h` : '-- km/h';
    liveAltitude.textContent = altitude !== null ? `${altitude.toFixed(1)} m` : '-- m';
    liveAccuracy.textContent = accuracy !== null ? `${accuracy.toFixed(1)} m` : '-- m';
    const latlngs = trackLine.getLatLngs();
    latlngs.push(here); 
    trackLine.setLatLngs(latlngs);
    trackLineCasing.setLatLngs(latlngs);
    if(orientationMode==='course' && prevLatLng){
      const bearing = bearingBetween(prevLatLng, here);
      rotateMap(-bearing);
      $compassArrow.style.transform=`translateY(4px) rotate(${bearing}deg)`;
    }
    stat.textContent = `距離 ${(distanceTravelled/1000).toFixed(2)} km`;
    checkNearAndSpeak(here);
  }
  function onPositionError(err){ toast('位置情報を取得できません'); }

  function startTracking(){
    if(!currentKey){ toast('KML/KMZを読み込んでください'); return; }
    unlockTTS();
    tracking=true; 
    start.disabled=true; 
    // stop.disabled=true; // 削除
    fabStop.style.display='grid'; 
    document.getElementById('recBadge').style.display='flex';
    enqueueSpeech(['評価を開始します']);
    liveInfoPanel.style.display = 'block';
    distanceTravelled=0; distanceTravelledSinceSpeak=0;
    trackPoints.length = 0;
    trackLine.setLatLngs([]); 
    trackLineCasing.setLatLngs([]);
    checkpointLayer.clearLayers();
    notified.clear();
    let sweep=0; clearInterval(startupSweepTimer);
    startupSweepTimer=setInterval(()=>{ if(!tracking){clearInterval(startupSweepTimer);return;}
      if(lastLatLng) checkNearAndSpeak(L.latLng(lastLatLng));
      if(++sweep>=10) clearInterval(startupSweepTimer);
    },2000);
    watchId=navigator.geolocation.watchPosition(onPosition,onPositionError,{enableHighAccuracy:true,maximumAge:1000,timeout:10000});
    gpsWeakTimer = setInterval(()=>{
      if(!tracking) return;
      const since = Date.now()-lastFixTime;
      if(since>15000 && !weakGpsWarned){ weakGpsWarned=true; toast('GPS信号が弱いです'); enqueueSpeech(['GPS信号が弱いです']); }
    },3000);
    cpBtn.disabled=false;
  }

  function stopTracking(){
    if(!tracking) return;
    tracking=false;
    navigator.geolocation.clearWatch?.(watchId); watchId=null;
    clearInterval(startupSweepTimer); clearInterval(gpsWeakTimer);
    start.disabled=false; 
    // stop.disabled=true; // 削除
    fabStop.style.display='none'; 
    document.getElementById('recBadge').style.display='none';
    liveInfoPanel.style.display = 'none';
    rotateMap(0); $compass.style.display='none';
    unlockTTS(); enqueueSpeech(['評価を終了します']);
    cpBtn.disabled=true;
    if (trackPoints.length === 0) {
        toast('走行記録がありません', 1500);
        return;
    }
    saveModal.style.display = 'flex';
    const now = new Date();
    const defaultFilename = `track_${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
    filenameInput.value = defaultFilename;
  }
  start.addEventListener('click', startTracking);
  // stop.addEventListener('click', stopTracking); // 削除
  fabStop.addEventListener('touchstart', (e)=>{ e.preventDefault(); stopTracking(); }, {passive:false});
  fabStop.addEventListener('click', stopTracking);

  recenter.addEventListener('click',()=>{
    if(lastLatLng) map.setView(lastLatLng, Math.max(map.getZoom()||16,16), {animate:true});
  });

  /* ==== チェックポイント ==== */
  cpBtn.addEventListener('click',()=>{
    if(!lastLatLng) { toast('現在地が未取得です'); return; }
    const memo = prompt('チェックポイントのメモ（任意）','');
    const m = L.marker(lastLatLng, {icon:iconOrange}).addTo(checkpointLayer);
    if(memo) m.bindPopup(escapeHTML(memo));
    cps.push({latlng:[lastLatLng.lat,lastLatLng.lng], memo:memo||''});
  });

  /* ==== GPX 保存 ==== */
  function clearTrackAndCps() {
    trackPoints.length = 0;
    cps.length = 0;
    trackLine.setLatLngs([]);
    trackLineCasing.setLatLngs([]);
    checkpointLayer.clearLayers();
  }

  saveYesBtn.addEventListener('click', () => {
    const filename = filenameInput.value || 'track';
    saveGPX(trackPoints, cps, filename);
    saveModal.style.display = 'none';
    clearTrackAndCps();
  });

  saveNoBtn.addEventListener('click', () => {
    saveModal.style.display = 'none';
    clearTrackAndCps();
  });

  function saveGPX(latlngs, cps, filename){
    const gpx = buildGPX(latlngs, cps);
    downloadText(gpx, `${filename}.gpx`, 'application/gpx+xml');
  }

  function buildGPX(latlngs, cps){
    const trkpts = latlngs.map(ll=>`<trkpt lat="${ll.lat}" lon="${ll.lng}"></trkpt>`).join('');
    const wpts   = cps.map(c=>`<wpt lat="${c.latlng[0]}" lon="${c.latlng[1]}"><name>${escapeXML(c.memo||'CP')}</name></wpt>`).join('');
    return `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="DriveEval" xmlns="http://www.topografix.com/GPX/1.1"><trk><name>drive</name><trkseg>${trkpts}</trkseg></trk>${wpts}</gpx>`;
  }

  function downloadText(text, name, mime){
    try{
      const blob = new Blob([text], {type: mime});
      const file = new File([blob], name, {type: mime});
      if (navigator.canShare?.({ files: [file] })) {
        navigator.share({ files: [file], title: name, text: '' })
          .catch(()=>{});
        return;
      }
      const url = URL.createObjectURL(blob);
      const opened = window.open(url, '_blank');
      if (!opened) {
        const a = document.createElement('a');
        a.href = url; a.download = name;
        document.body.appendChild(a); a.click(); a.remove();
      }
      setTimeout(()=>URL.revokeObjectURL(url), 4000);
    }catch(e){
      const win = window.open('', '_blank');
      if (win){
        win.document.open();
        win.document.write(`<pre style="white-space:pre-wrap;word-break:break-all;">${escapeHTML(text)}</pre>`);
        win.document.close();
      }else{
        alert('保存に失敗しました。ポップアップブロックを解除して再試行してください。');
      }
    }
  }

  /* ==== サービスワーカー（即時更新） ==== */
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('sw.js').then(reg=>{
      if(reg.waiting){ reg.waiting.postMessage({type:'SKIP_WAITING'}); }
      reg.addEventListener('updatefound',()=>{
        const sw=reg.installing; sw?.addEventListener('statechange',()=>{
          if(sw.state==='installed'){ reg.waiting?.postMessage({type:'SKIP_WAITING'}); }
        });
      });
      navigator.serviceWorker.addEventListener('controllerchange',()=> location.reload());
    }).catch(()=>{});
  }

})();
</script>
</body>
</html>
